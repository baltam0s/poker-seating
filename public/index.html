<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Poker Seating Generator</title>
  <link rel="icon" type="image/png" href="favicon.png">
  <style>
    :root {
      --primary: #667eea;
      --secondary: #764ba2;
      --bg-light: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --bg-dark: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      --card-light: white;
      --card-dark: #1e1e2e;
      --text-light: #333;
      --text-dark: #e0e0e0;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg-light);
      min-height: 100vh;
      padding: 10px;
      transition: background 0.3s ease;
    }

    body.dark-mode {
      background: var(--bg-dark);
      color: var(--text-dark);
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 15px 20px;
      margin-bottom: 20px;
      position: relative;
    }

    .header h1 {
      font-size: 1.5em;
      margin: 0;
      flex-grow: 1;
      text-align: center;
    }

    .icon-btn {
      background: var(--card-light);
      color: var(--text-light);
      border: 2px solid var(--primary);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 1.2em;
      transition: all 0.2s;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      z-index: 10;
    }

    body.dark-mode .icon-btn {
      background: var(--card-dark);
      color: var(--text-dark);
      border-color: #ffd700;
    }

    .icon-btn:hover {
      transform: scale(1.1);
    }

    .main-content {
      display: grid;
      gap: 20px;
    }

    @media (min-width: 1000px) {
      .main-content {
        grid-template-columns: 350px 1fr;
      }
    }

    .card {
      background: var(--card-light);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      transition: 0.3s;
    }

    body.dark-mode .card {
      background: var(--card-dark);
      color: var(--text-dark);
    }

    h2 {
      margin-bottom: 15px;
      font-size: 1.4em;
    }

    button {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      transition: 0.2s;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      opacity: 0.9;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    input[type="text"],
    input[type="password"],
    select {
      width: 100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 8px;
      margin-bottom: 10px;
      background: white;
      color: #333;
    }

    body.dark-mode input,
    body.dark-mode select {
      background: #2a2a3e;
      border-color: #444;
      color: white;
    }

    .player-list {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      max-height: 300px;
      overflow-y: auto;
    }

    .player-checkbox {
      padding: 8px;
      background: #f5f5f5;
      border-radius: 6px;
      display: flex;
      align-items: center;
      cursor: pointer;
    }

    body.dark-mode .player-checkbox {
      background: #2a2a3e;
    }

    .player-checkbox input {
      margin-right: 8px;
    }

    /* Table Visualization */
    .poker-table-container {
      min-height: 400px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .poker-table {
      width: 100%;
      max-width: 600px;
      height: 300px;
      background: #2d8b2d;
      border: 12px solid #8b4513;
      border-radius: 60px;
      position: relative;
      box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.5);
    }

    .seat {
      position: absolute;
      padding: 5px 10px;
      background: white;
      border-radius: 8px;
      transform: translate(-50%, -50%);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      border: 2px solid var(--primary);
      text-align: center;
      min-width: 60px;
      /* Reduced from 80 */
      font-size: 0.9em;
      color: #333;
    }

    @media (max-width: 600px) {
      .seat {
        padding: 2px 5px;
        min-width: auto;
        font-size: 0.75em;
      }

      .poker-table {
        border-width: 8px;
        height: 250px;
      }
    }

    .seat.eliminated {
      background: #fee;
      border-color: #e53e3e;
      opacity: 0.7;
      text-decoration: line-through;
    }

    .eliminate-btn {
      background: #e53e3e;
      width: 20px;
      height: 20px;
      padding: 0;
      border-radius: 50%;
      font-size: 12px;
      position: absolute;
      top: -10px;
      right: -10px;
      line-height: 20px;
    }

    /* Results Section */
    .results-panel {
      display: none;
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #ddd;
    }

    .results-panel.show {
      display: block;
    }

    .results-form label {
      display: block;
      margin: 10px 0 5px;
      font-size: 0.9em;
    }

    /* Stats & History */
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      border-bottom: 2px solid #ddd;
    }

    .tab {
      background: none;
      color: inherit;
      padding: 10px;
      width: auto;
      border-bottom: 3px solid transparent;
      border-radius: 0;
    }

    .tab.active {
      border-color: var(--primary);
      color: var(--primary);
    }

    .table-wrap {
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th,
    td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #eee;
    }

    body.dark-mode th,
    body.dark-mode td {
      border-color: #444;
    }

    /* Utility */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 12px;
      width: 90%;
      max-width: 400px;
    }

    body.dark-mode .modal-content {
      background: #1e1e2e;
    }

    .status-msg {
      margin-top: 10px;
      padding: 10px;
      border-radius: 6px;
      display: none;
    }

    .status-msg.error {
      background: #fee;
      color: #c00;
      display: block;
    }

    .status-msg.success {
      background: #eef;
      color: #00c;
      display: block;
    }

    .timer-display {
      font-size: 3em;
      font-family: monospace;
      text-align: center;
      margin: 10px 0;
      font-weight: bold;
    }

    .timer-controls {
      display: flex;
      gap: 10px;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <button class="icon-btn" onclick="toggleTheme()" title="Toggle Theme">üåô</button>
      <h1>üé∞ Poker Seating</h1>
      <button class="icon-btn" onclick="toggleAdmin()" title="Admin Settings">‚öôÔ∏è</button>
    </div>

    <div class="main-content">
      <!-- SETUP PANEL -->
      <div class="card">
        <h2>üéÆ Setup</h2>
        <div id="setupSection">
          <input type="text" id="newPlayer" placeholder="Add new player (Enter)" onkeypress="handlePlayerInput(event)">
          <div class="player-list" id="playerList"></div>
          <br>
          <button id="generateBtn" onclick="generateSeating()">Generate Seating</button>
          <div id="gameStatus" class="status-msg"></div>
        </div>

        <!-- RESULTS PANEL (Hidden until game starts) -->
        <div id="resultsPanel" class="results-panel">
          <h3>üèÜ Submit Results</h3>
          <p style="font-size: 0.85em; opacity: 0.8; margin-bottom: 15px;">Game is locked. Submit results to finish.</p>

          <div class="results-form">
            <label>ü•á 1st Place (Winner)</label>
            <select id="winner1"></select>

            <label>ü•à 2nd Place (Optional)</label>
            <select id="winner2">
              <option value="">-- None --</option>
            </select>

            <label>ü•â 3rd Place (Optional)</label>
            <select id="winner3">
              <option value="">-- None --</option>
            </select>
          </div>
          <br>
          <button onclick="submitResults()" style="background: linear-gradient(135deg, #FFD700, #FFA500);">Finish Game &
            Save</button>
          <button onclick="cancelGame()" style="background: #e53e3e; margin-top: 10px; font-size: 0.9em;">Cancel
            Game</button>
        </div>
      </div>

      <!-- TABLE & TIMER -->
      <div>
        <div class="card">
          <h2>‚è±Ô∏è Blinds: <span id="blindLevel">Lvl 1</span></h2>
          <div class="timer-display" id="timer">45:00</div>
          <div class="timer-controls">
            <button onclick="timer.start()">‚ñ∂</button>
            <button onclick="timer.pause()">‚è∏</button>
            <button onclick="timer.reset()">‚Ü∫</button>
          </div>
        </div>
        <br>
        <div class="card">
          <h2>ü™ë Table</h2>
          <div class="poker-table-container" id="tableContainer">
            <div style="opacity: 0.5">Waiting for game...</div>
          </div>
        </div>
      </div>
    </div>

    <br>
    <!-- STATS & HISTORY -->
    <div class="card">
      <div class="tabs">
        <button class="tab active" onclick="setTab('stats')">üìä Stats</button>
        <button class="tab" onclick="setTab('history')">üìú History</button>
      </div>
      <div id="tab-stats" class="table-wrap">
        <table id="statsTable">
          <thead>
            <tr>
              <th>Player</th>
              <th>Games</th>
              <th>Wins</th>
              <th>Win %</th>
              <th>Top 3</th>
              <th>Top 3 %</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div id="tab-history" class="table-wrap" style="display:none">
        <table id="historyTable">
          <thead>
            <tr>
              <th>Date</th>
              <th>Winner</th>
              <th>2nd</th>
              <th>3rd</th>
              <th>Players</th>
            </tr>
          </thead>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Admin Modal -->
  <div id="adminModal" class="modal">
    <div class="modal-content">
      <h2>Admin Login</h2>
      <input type="password" id="adminPass" placeholder="Password">
      <button onclick="adminLogin()">Login</button>
      <button onclick="document.getElementById('adminModal').classList.remove('show')"
        style="background: #777; margin-top:10px">Close</button>
    </div>
  </div>

  <!-- Edit Game Modal -->
  <div id="editGameModal" class="modal">
    <div class="modal-content">
      <h2>Edit Game</h2>
      <input type="hidden" id="editGameId">
      <div id="editGameForm" class="results-form">
        <label>ü•á Winner</label>
        <select id="editWinner"></select>

        <label>ü•à 2nd Place</label>
        <select id="editSecond"></select>

        <label>ü•â 3rd Place</label>
        <select id="editThird"></select>
      </div>
      <br>
      <button onclick="saveEdit()" style="background: linear-gradient(135deg, #FFD700, #FFA500);">Save Changes</button>
      <button onclick="document.getElementById('editGameModal').classList.remove('show')"
        style="background: #777; margin-top:10px">Cancel</button>
    </div>
  </div>

  <script>
    // --- STATE ---
    let state = {
      players: JSON.parse(localStorage.getItem('pokerPlayers') || '[]'),
      gameId: null,
      activePlayers: [],
      eliminated: new Set(),
      isGameActive: false,
      isAdmin: !!localStorage.getItem('adminToken'),
      history: []
    };

    // --- INIT ---
    window.addEventListener('DOMContentLoaded', () => {
      // Expose functions to global scope for HTML onclick access
      window.editGame = editGame;
      window.deleteGame = deleteGame;
      window.saveEdit = saveEdit;
      window.toggleElimination = toggleElimination;
      window.handlePlayerInput = handlePlayerInput;
      window.generateSeating = generateSeating;
      window.submitResults = submitResults;
      window.cancelGame = cancelGame;
      window.toggleAdmin = toggleAdmin;
      window.adminLogin = adminLogin;
      window.toggleTheme = toggleTheme;
      window.setTab = setTab;

      if (state.players.length === 0) {
        state.players = ['Dime', 'Laziƒá', 'Peƒëa', 'ƒêovani', 'Bane', 'Miha', '≈†egi'];
      }
      if (localStorage.getItem('darkMode') === '1') document.body.classList.add('dark-mode');

      renderPlayerList();
      loadStats();
      loadHistory();
      timer.init();

      // Check for server-side active game
      checkForActiveGame();
    });

    async function checkForActiveGame() {
      try {
        const res = await fetch('/api/active-game');
        const activeGame = await res.json();

        if (activeGame) {
          restoreGame(activeGame);
        } else {
          // Legacy/Fallback: Check local storage logic or clear it
          // Actually, if server says no game, we should trust it and clear local state if inconsistent
          const localGame = JSON.parse(localStorage.getItem('activeGame') || 'null');
          if (localGame && state.gameId !== localGame.gameId) {
            // Mismatch or stale local data
            localStorage.removeItem('activeGame');
          }
        }
      } catch (e) {
        console.error("Failed to check active game:", e);
      }
    }

    // --- CORE LOGIC ---

    function handlePlayerInput(e) {
      if (e.key === 'Enter') {
        const name = e.target.value.trim();
        if (name && !state.players.includes(name)) {
          state.players.push(name);
          localStorage.setItem('pokerPlayers', JSON.stringify(state.players));
          renderPlayerList();
          e.target.value = '';
        }
      }
    }

    function renderPlayerList() {
      const list = document.getElementById('playerList');
      list.innerHTML = state.players.map(p => `
                <label class="player-checkbox">
                    <input type="checkbox" value="${p}" ${state.activePlayers.includes(p) ? 'checked' : ''}>
                    ${p}
                </label>
            `).join('');
    }

    async function generateSeating() {
      const selected = Array.from(document.querySelectorAll('#playerList input:checked')).map(cb => cb.value);
      if (selected.length < 2) return alert("Select at least 2 players!");

      showMessage('Generating...', 'status-msg');
      document.getElementById('generateBtn').disabled = true;

      try {
        const res = await fetch('/api/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ players: selected })
        });
        const data = await res.json();

        if (data.error) throw new Error(data.error);

        // GAME START
        state.gameId = data.gameId;
        state.activePlayers = data.seating;
        state.eliminated = new Set();
        state.isGameActive = true;

        // Save recovery state
        localStorage.setItem('activeGame', JSON.stringify({
          gameId: state.gameId,
          seating: state.activePlayers
        }));

        updateUIForGameStart();
        renderTable(data.seating);
        showMessage('');
        timer.reset();

      } catch (e) {
        alert(e.message);
        document.getElementById('generateBtn').disabled = false;
      }
    }

    function restoreGame(gameData) {
      state.gameId = gameData.id || gameData.gameId; // Handle both formats
      state.activePlayers = gameData.seating;
      state.isGameActive = true;
      state.eliminated = new Set(); // Loss of elimination state on refresh is acceptable for now
      updateUIForGameStart();
      renderTable(state.activePlayers);
    }

    function updateUIForGameStart() {
      document.getElementById('generateBtn').disabled = true;
      document.getElementById('playerList').style.pointerEvents = 'none';
      document.getElementById('playerList').style.opacity = '0.7';

      const resultsPanel = document.getElementById('resultsPanel');
      resultsPanel.classList.add('show');

      updateResultDropdowns();
    }

    function updateResultDropdowns() {
      const opts = state.activePlayers.map(p => `<option value="${p}">${p}</option>`).join('');
      document.getElementById('winner1').innerHTML = `<option value="" disabled selected>Select Winner</option>` + opts;
      document.getElementById('winner2').innerHTML = `<option value="">-- None --</option>` + opts;
      document.getElementById('winner3').innerHTML = `<option value="">-- None --</option>` + opts;
    }

    async function cancelGame() {
      if (!confirm("Cancel this game? It will be deleted permanently.")) return;

      if (state.gameId) {
        if (state.isAdmin) {
          await deleteGame(state.gameId);
        } else {
          // Non-admins can't "delete" from DB via admin API, 
          // but if the game is active (no winner), we might need a way to void it.
          // For now, if we are strictly locking, maybe ONLY admins can cancel?
          // Or we add a public /api/cancel endpoint. 
          // Given the request, let's assume we want to clear it.
          // For this iteration, let's try to delete it if we have the ID, 
          // but we need an auth token.
          // If not admin, we might be stuck. 
          // Let's rely on the previous logic but also try to clear server state if possible.
          // Actually, the best way is to let anyone cancel the active game if they are the "owner"
          // but we don't track owner.
          // Let's alert the user they need admin to delete a server-tracked game.
          if (!state.isAdmin) {
            alert("Only admins can fully delete a tracked game from the server. This will only clear your local view.");
          }
        }
      }
      endGameCleanup();
    }

    function endGameCleanup() {
      state.isGameActive = false;
      state.gameId = null;
      state.activePlayers = [];
      localStorage.removeItem('activeGame');

      document.getElementById('generateBtn').disabled = false;
      document.getElementById('playerList').style.pointerEvents = 'auto';
      document.getElementById('playerList').style.opacity = '1';
      document.getElementById('resultsPanel').classList.remove('show');
      document.getElementById('tableContainer').innerHTML = '<div style="opacity: 0.5">Waiting for game...</div>';
      timer.pause();
    }

    async function submitResults() {
      const first = document.getElementById('winner1').value;
      const second = document.getElementById('winner2').value;
      const third = document.getElementById('winner3').value;

      if (!first) return alert("Please select a winner (1st place)!");
      if (first === second || (third && (third === first || third === second))) {
        return alert("A player cannot hold multiple places!");
      }

      try {
        const res = await fetch('/api/results', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            gameId: state.gameId,
            first, second, third
          })
        });
        if (!res.ok) throw new Error("Failed to save results");

        alert("Results saved! üèÜ");
        endGameCleanup();
        loadStats();
        loadHistory();

      } catch (e) {
        alert(e.message);
      }
    }

    function renderTable(seating) {
      const container = document.getElementById('tableContainer');
      const positions = calculateRectangularPositions(seating.length);

      const html = seating.map((p, i) => {
        const pos = positions[i];
        return `<div class="seat" id="seat-${i}" style="left:${pos.x}%; top:${pos.y}%">
                    <div>${p}</div>
                    <button class="eliminate-btn" onclick="toggleElimination('${p}', ${i})">√ó</button>
                </div>`;
      }).join('');

      container.innerHTML = `<div class="poker-table"><div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:rgba(255,255,255,0.3);font-size:2em">‚ô†‚ô•‚ô£‚ô¶</div>${html}</div>`;
    }

    function calculateRectangularPositions(numSeats) {
      const positions = [];
      // Special case for 7 players: distribute as 2-2-2-1
      if (numSeats === 7) {
        positions.push({ x: 30, y: 5 }); positions.push({ x: 70, y: 5 }); // Top
        positions.push({ x: 95, y: 35 }); positions.push({ x: 95, y: 65 }); // Right
        positions.push({ x: 70, y: 95 }); positions.push({ x: 30, y: 95 }); // Bottom
        positions.push({ x: 5, y: 50 }); // Left
        return positions;
      }

      let distribution = [];
      if (numSeats <= 2) distribution = [numSeats, 0, 0, 0];
      else if (numSeats === 3) distribution = [1, 1, 1, 0]; // 1 Top, 1 Right, 1 Bottom
      else if (numSeats === 4) distribution = [1, 1, 1, 1];
      else if (numSeats === 5) distribution = [2, 1, 2, 0];
      else if (numSeats === 6) distribution = [2, 1, 2, 1];
      else distribution = [2, 2, 2, 2]; // 8 max usually

      const [top, right, bottom, left] = distribution;

      // Top (Left to Right)
      for (let i = 0; i < top; i++) {
        const x = top === 1 ? 50 : (i === 0 ? 30 : 70);
        positions.push({ x, y: 5 });
      }
      // Right (Top to Bottom)
      for (let i = 0; i < right; i++) {
        const y = right === 1 ? 50 : (i === 0 ? 35 : 65);
        positions.push({ x: 95, y });
      }
      // Bottom (Right to Left)
      for (let i = 0; i < bottom; i++) {
        const x = bottom === 1 ? 50 : (i === 0 ? 70 : 30);
        positions.push({ x, y: 95 });
      }
      // Left (Bottom to Top)
      for (let i = 0; i < left; i++) {
        const y = left === 1 ? 50 : (i === 0 ? 65 : 35);
        positions.push({ x: 5, y });
      }
      return positions;
    }

    function toggleElimination(player, idx) {
      const el = document.getElementById(`seat-${idx}`);
      if (el.classList.contains('eliminated')) {
        el.classList.remove('eliminated');
        state.eliminated.delete(player);
      } else {
        el.classList.add('eliminated');
        state.eliminated.add(player);
      }
    }

    // --- STATS & HISTORY ---
    async function loadStats() {
      const res = await fetch('/api/stats');
      const data = await res.json();
      const tbody = document.querySelector('#statsTable tbody');
      tbody.innerHTML = data.map(r => `
                <tr>
                    <td>${r.player}</td>
                    <td>${r.gamesPlayed}</td>
                    <td>${r.wins}</td>
                    <td>${r.winRate}%</td>
                    <td>${r.top3}</td>
                    <td>${r.top3Rate}%</td>
                </tr>
            `).join('') || '<tr><td colspan="6">No stats yet</td></tr>';
    }

    async function loadHistory() {
      const res = await fetch('/api/history');
      const data = await res.json();
      state.history = data; // Save for edit lookup

      // Update Header
      const theadRow = document.querySelector('#historyTable thead tr');
      if (state.isAdmin) {
        if (!theadRow.querySelector('.action-col')) {
          const th = document.createElement('th');
          th.className = 'action-col';
          th.textContent = 'Action';
          theadRow.appendChild(th);
        }
      } else {
        const th = theadRow.querySelector('.action-col');
        if (th) th.remove();
      }

      const tbody = document.querySelector('#historyTable tbody');
      tbody.innerHTML = data.map(g => {
        const date = new Date(g.created_at).toLocaleDateString('en-GB');
        const pList = g.players.join(', ');
        const deleteBtn = state.isAdmin
          ? `<td>
                 <button onclick="editGame(${g.id})" style="background:#f39c12;padding:5px 10px;width:auto;font-size:0.8em;margin-right:5px">Edit</button>
                 <button onclick="deleteGame(${g.id})" style="background:#e53e3e;padding:5px 10px;width:auto;font-size:0.8em">Del</button>
               </td>`
          : '';
        return `<tr>
                    <td>${date}</td>
                    <td style="color:#28a745;font-weight:bold">${g.winner || '-'}</td>
                    <td>${g.second_place || '-'}</td>
                    <td>${g.third_place || '-'}</td>
                    <td style="font-size:0.8em;color:#666">${pList}</td>
                    ${deleteBtn}
                </tr>`;
      }).join('') || `<tr><td colspan="${state.isAdmin ? 6 : 5}">No history yet</td></tr>`;
    }

    // HTML Escape helper to prevent breakage in onclick


    function editGame(id) {
      // Find game in state.history
      const game = state.history.find(g => g.id === id);
      if (!game) return alert("Game not found in local state");

      document.getElementById('editGameId').value = id;

      // Populate dropdowns with players from that game
      const players = game.players;
      const opts = players.map(p => `<option value="${p}">${p}</option>`).join('');

      const wSelect = document.getElementById('editWinner');
      const sSelect = document.getElementById('editSecond');
      const tSelect = document.getElementById('editThird');

      wSelect.innerHTML = `<option value="">-- Select --</option>` + opts;
      sSelect.innerHTML = `<option value="">-- None --</option>` + opts;
      tSelect.innerHTML = `<option value="">-- None --</option>` + opts;

      wSelect.value = game.winner || '';
      sSelect.value = game.second_place || '';
      tSelect.value = game.third_place || '';

      document.getElementById('editGameModal').classList.add('show');
    }

    async function saveEdit() {
      const id = document.getElementById('editGameId').value;
      const first = document.getElementById('editWinner').value;
      const second = document.getElementById('editSecond').value;
      const third = document.getElementById('editThird').value;

      if (!first && !second && !third) return alert("Nothing to save?");

      // Validation: unique places
      if (first && (first === second || first === third)) return alert("One player cannot hold multiple places");
      if (second && second === third) return alert("One player cannot hold multiple places");

      try {
        const token = localStorage.getItem('adminToken');
        const res = await fetch(`/api/admin/game/${id}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            winner: first || null,
            second_place: second || null,
            third_place: third || null
          })
        });

        if (!res.ok) {
          const d = await res.json();
          throw new Error(d.error || "Update failed");
        }

        alert("Game updated!");
        document.getElementById('editGameModal').classList.remove('show');
        loadStats();
        loadHistory();

      } catch (e) {
        alert(e.message);
      }
    }

    async function deleteGame(id) {
      if (!confirm("Start deletion? This cannot be undone.")) return;

      try {
        const token = localStorage.getItem('adminToken');
        const res = await fetch(`/api/admin/game/${id}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (res.ok) {
          // If the deleted game was the active one, clear local state
          if (state.gameId === id) {
            endGameCleanup();
          }
          loadStats();
          loadHistory();
          alert("Game deleted.");
        } else {
          alert("Failed to delete. URL might be wrong or unauthorized.");
        }
      } catch (e) {
        console.error(e);
        alert("Error deleting game");
      }
    }

    function setTab(name) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`.tab[onclick="setTab('${name}')"]`).classList.add('active');
      document.getElementById('tab-stats').style.display = name === 'stats' ? 'block' : 'none';
      document.getElementById('tab-history').style.display = name === 'history' ? 'block' : 'none';
    }

    // --- UTILS ---
    function toggleTheme() {
      document.body.classList.toggle('dark-mode');
      localStorage.setItem('darkMode', document.body.classList.contains('dark-mode') ? '1' : '0');
    }
    function toggleAdmin() {
      if (state.isAdmin) {
        if (confirm('Logout?')) {
          localStorage.removeItem('adminToken');
          state.isAdmin = false;
          window.location.reload();
        }
      } else {
        document.getElementById('adminModal').classList.add('show');
      }
    }
    async function adminLogin() {
      const p = document.getElementById('adminPass').value;
      const res = await fetch('/api/admin/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password: p })
      });
      const d = await res.json();
      if (d.token) {
        localStorage.setItem('adminToken', d.token);
        state.isAdmin = true;
        document.getElementById('adminModal').classList.remove('show');
        loadHistory(); // Reload history to show delete buttons
        alert("Logged in");
      } else {
        alert(d.error || 'Login failed');
      }
    }
    function showMessage(msg, type = 'success') {
      const el = document.getElementById('gameStatus');
      el.textContent = msg;
      el.className = 'status-msg ' + type;
      if (!msg) el.style.display = 'none';
    }

    // --- TIMER (Robust & Persistent) ---
    const timer = {
      interval: null,

      init() {
        // Recover state from localStorage
        const status = localStorage.getItem('timerStatus') || 'stopped';
        const level = parseInt(localStorage.getItem('timerLevel')) || 1;
        const remaining = parseInt(localStorage.getItem('timerRemaining')) || (45 * 60);
        const endTime = parseInt(localStorage.getItem('timerEndTime'));

        if (status === 'running' && endTime) {
          const now = Date.now();
          if (now >= endTime) {
            // Timer expired while away
            this.handleExpiry(now);
          } else {
            // Resume
            this.startInterval();
          }
        }

        this.updateDisplay();
      },

      start() {
        const status = localStorage.getItem('timerStatus') || 'stopped';
        if (status === 'running') return;

        let remaining = parseInt(localStorage.getItem('timerRemaining')) || (45 * 60);

        // Calculate new Target Time
        const endTime = Date.now() + (remaining * 1000);

        localStorage.setItem('timerStatus', 'running');
        localStorage.setItem('timerEndTime', endTime);
        localStorage.setItem('timerRemaining', remaining); // Valid backup

        this.startInterval();
      },

      startInterval() {
        if (this.interval) clearInterval(this.interval);

        this.update(); // Immediate update

        this.interval = setInterval(() => {
          this.update();
        }, 1000);
      },

      pause() {
        const status = localStorage.getItem('timerStatus');
        if (status !== 'running') return;

        // Calculate actual remaining time and save it
        const endTime = parseInt(localStorage.getItem('timerEndTime'));
        const remaining = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));

        localStorage.setItem('timerStatus', 'paused');
        localStorage.setItem('timerRemaining', remaining);
        localStorage.removeItem('timerEndTime');

        if (this.interval) clearInterval(this.interval);
        this.interval = null;
        this.updateDisplay();
      },

      reset() {
        if (this.interval) clearInterval(this.interval);
        this.interval = null;

        localStorage.setItem('timerStatus', 'stopped');
        localStorage.setItem('timerRemaining', 45 * 60);
        localStorage.setItem('timerLevel', 1);
        localStorage.removeItem('timerEndTime');

        this.updateDisplay();
      },

      update() {
        const endTime = parseInt(localStorage.getItem('timerEndTime'));
        if (!endTime) return;

        const remaining = Math.ceil((endTime - Date.now()) / 1000);

        if (remaining <= 0) {
          this.handleExpiry(Date.now());
        } else {
          // Just update display (don't constantly write strictly to storage to avoid I/O thrashing, 
          // but we rely on endTime which is static)
          this.updateDisplay(remaining);
        }
      },

      handleExpiry(now) {
        // Level Up
        let level = parseInt(localStorage.getItem('timerLevel')) || 1;
        level++;

        // Reset for next level
        const newDuration = 45 * 60;
        const nextEndTime = now + (newDuration * 1000); // Immediately start next level? User usually wants this continuous

        localStorage.setItem('timerLevel', level);
        localStorage.setItem('timerRemaining', newDuration);
        localStorage.setItem('timerEndTime', nextEndTime);

        // Play Sound
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        osc.connect(ctx.destination);
        osc.start(); osc.stop(ctx.currentTime + 1.0);

        this.updateDisplay();
      },

      updateDisplay(secondsOverride) {
        let seconds = secondsOverride;
        if (seconds === undefined) {
          seconds = parseInt(localStorage.getItem('timerRemaining')) || (45 * 60);
          const status = localStorage.getItem('timerStatus');
          if (status === 'running') {
            const endTime = parseInt(localStorage.getItem('timerEndTime'));
            if (endTime) {
              seconds = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));
            }
          }
        }

        const level = localStorage.getItem('timerLevel') || 1;
        document.getElementById('blindLevel').textContent = `Lvl ${level}`;

        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        document.getElementById('timer').textContent = `${m}:${s.toString().padStart(2, '0')}`;
      }
    };
  </script>
</body>

</html>